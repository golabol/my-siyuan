diff --git a/.gitignore b/.gitignore
index b4718a8ca..3b2e753ef 100644
--- a/.gitignore
+++ b/.gitignore
@@ -39,3 +39,6 @@ yarn.lock
 
 # Workflows
 **/__pycache__
+
+# Ignore Patches
+*.patch
\ No newline at end of file
diff --git a/app/src/config/appearance.ts b/app/src/config/appearance.ts
index f36839239..1bf2892ea 100644
--- a/app/src/config/appearance.ts
+++ b/app/src/config/appearance.ts
@@ -119,6 +119,35 @@ export const appearance = {
         ${window.siyuan.languages.showInFolder}
     </button>
 </div>
+<div class="b3-label config__item${isBrowser() ? " fn__none" : " fn__flex"}">
+    <div class="fn__flex-1">
+        Remote Icon Provider
+        <div class="b3-label__text">Select remote provider for icon search</div>
+    </div>
+    <span class="fn__space"></span>
+    <select id="remoteIconProvider" class="b3-select fn__flex-center fn__size200">
+        <option value=""></option>
+        <option value="iconFinder" ${window.siyuan.config.appearance.remoteIconProvider === 'iconFinder' ? "selected" : ""}>IconFinder</option>
+        <option value="icon8" ${window.siyuan.config.appearance.remoteIconProvider === 'icon8' ? "selected" : ""}>Icon8</option>
+        <option value="flatIcon" ${window.siyuan.config.appearance.remoteIconProvider === 'flatIcon' ? "selected" : ""}>FlatIcon</option>
+    </select>
+</div>
+<div class="b3-label config__item${isBrowser() ? " fn__none" : " fn__flex"}">
+    <div class="fn__block">
+        IconFinder API Key
+        <div class="b3-label__text">Your IconFinder.com Api Key</div>
+        <span class="fn__hr"></span>
+        <input class="b3-text-field fn__block" id="iconFinderAPIKey"/>
+    </div>
+</div>
+<div class="b3-label config__item${isBrowser() ? " fn__none" : " fn__flex"}">
+    <div class="fn__block">
+        FlatIcon API Key
+        <div class="b3-label__text">Your FlatIcon.com Api Key</div>
+        <span class="fn__hr"></span>
+        <input class="b3-text-field fn__block" id="flatIconAPIKey"/>
+    </div>
+</div>
 <div class="b3-label fn__flex config__item">
    <div class="fn__flex-1">
         ${window.siyuan.languages.resetLayout}
@@ -184,6 +213,9 @@ export const appearance = {
             lightThemes: window.siyuan.config.appearance.lightThemes,
             icons: window.siyuan.config.appearance.icons,
             lang: (appearance.element.querySelector("#lang") as HTMLSelectElement).value,
+            remoteIconProvider: (appearance.element.querySelector("#remoteIconProvider") as HTMLSelectElement).value,
+            iconFinderAPIKey: (appearance.element.querySelector("#iconFinderAPIKey") as HTMLInputElement).value,
+            flatIconAPIKey: (appearance.element.querySelector("#flatIconAPIKey") as HTMLInputElement).value,
             closeButtonBehavior: (appearance.element.querySelector("#closeButtonBehavior") as HTMLInputElement).checked ? 1 : 0,
             hideStatusBar: (appearance.element.querySelector("#hideStatusBar") as HTMLInputElement).checked,
         }, async response => {
@@ -252,6 +284,13 @@ export const appearance = {
                 appearance._send();
             });
         });
+        (appearance.element.querySelector("#iconFinderAPIKey") as HTMLInputElement).value = window.siyuan.config.appearance.iconFinderAPIKey;
+        (appearance.element.querySelector("#flatIconAPIKey") as HTMLInputElement).value = window.siyuan.config.appearance.flatIconAPIKey;
+        appearance.element.querySelectorAll("input").forEach((item) => {
+            item.addEventListener("change", () => {
+                appearance._send();
+            });
+        });
     },
     onSetAppearance(data: Config.IAppearance) {
         if (data.lang !== window.siyuan.config.appearance.lang) {
diff --git a/app/src/constants.ts b/app/src/constants.ts
index 5fe29ffaf..7b63ebd7a 100644
--- a/app/src/constants.ts
+++ b/app/src/constants.ts
@@ -601,7 +601,7 @@ export abstract class Constants {
             data: [
                 [{
                     type: "file",
-                    size: {width: 232, height: 0},
+                    size: {width: 265, height: 0},
                     show: true,
                     icon: "iconFiles",
                     hotkeyLangId: "fileTree",
diff --git a/app/src/emoji/index.ts b/app/src/emoji/index.ts
index df3f8baf7..56b4e80c5 100644
--- a/app/src/emoji/index.ts
+++ b/app/src/emoji/index.ts
@@ -1,5 +1,5 @@
 import {getRandom, isMobile} from "../util/functions";
-import {fetchPost} from "../util/fetch";
+import {fetchPost, fetchSyncPost} from "../util/fetch";
 import {Constants} from "../constants";
 import {Files} from "../layout/dock/Files";
 /// #if !MOBILE
@@ -12,6 +12,22 @@ import {setPosition} from "../util/setPosition";
 import {setStorageVal} from "../protyle/util/compatibility";
 import * as dayjs from "dayjs";
 
+// Add debounce utility
+function debounce<T extends (...args: any[]) => any>(
+  func: T,
+  wait: number
+): (...args: Parameters<T>) => void {
+  let timeout: number;
+  return function executedFunction(...args: Parameters<T>) {
+    const later = () => {
+      clearTimeout(timeout);
+      func(...args);
+    };
+    clearTimeout(timeout);
+    timeout = setTimeout(later, wait);
+  };
+}
+
 export const getRandomEmoji = () => {
     const emojis = window.siyuan.emojis[getRandom(0, window.siyuan.emojis.length - 1)];
     if (typeof emojis.items[getRandom(0, emojis.items.length - 1)] === "undefined") {
@@ -31,7 +47,7 @@ export const unicode2Emoji = (unicode: string, className = "", needSpan = false,
         emoji = `<img class="${className}" ${lazy ? "data-" : ""}src="/emojis/${unicode}"/>`;
     } else {
         try {
-            unicode.split("-").forEach(item => {
+            (unicode || "").split("-").forEach(item => {
                 if (item.length < 5) {
                     emoji += String.fromCodePoint(parseInt("0" + item, 16));
                 } else {
@@ -85,7 +101,7 @@ export const lazyLoadEmojiImg = (element: Element) => {
     });
 };
 
-export const filterEmoji = (key = "", max?: number) => {
+export const filterEmoji = async (key = "", max?: number, triggered_by: "slash_hint" | "doc_notebook" = "doc_notebook") => {
     let html = "";
     const recentEmojis: IEmojiItem[] = [];
     if (key) {
@@ -94,6 +110,9 @@ export const filterEmoji = (key = "", max?: number) => {
     let maxCount = 0;
     let keyHTML = "";
     const customStore: IEmojiItem[] = [];
+    let externalIconsContent = "";
+
+    // Process local emojis
     window.siyuan.emojis.forEach((category, index) => {
         if (!key) {
             html += `<div class="emojis__title" data-type="${index + 1}">${getEmojiTitle(index)}</div><div style="min-height:${index === 0 ? "30px" : "300px"}" class="emojis__content"${index > 1 ? ' data-index="' + index + '"' : ""}>`;
@@ -102,40 +121,40 @@ export const filterEmoji = (key = "", max?: number) => {
             html += `<div style="margin-left: 4px">${window.siyuan.languages.setEmojiTip}</div>`;
         }
 
-        category.items.forEach(emoji => {
+        (category.items || []).forEach((emoji: IEmojiItem) => {
             if (key) {
-                if (window.siyuan.config.editor.emoji.includes(emoji.unicode) &&
-                    (unicode2Emoji(emoji.unicode) === key ||
-                        emoji.keywords.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                        emoji.description.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                        emoji.description_zh_cn.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                        emoji.description_ja_jp.toLowerCase().indexOf(key.toLowerCase()) > -1)
+                if ((window.siyuan.config.editor.emoji || []).includes(emoji.unicode || '') &&
+                    (unicode2Emoji(emoji.unicode || '') === key ||
+                        (emoji.keywords || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                        (emoji.description || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                        (emoji.description_zh_cn || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                        (emoji.description_ja_jp || '').toLowerCase().indexOf(key.toLowerCase()) > -1)
                 ) {
                     recentEmojis.push(emoji);
                 }
                 if (max && maxCount > max) {
                     return;
                 }
-                if (unicode2Emoji(emoji.unicode) === key ||
-                    emoji.keywords.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                    emoji.description.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                    emoji.description_zh_cn.toLowerCase().indexOf(key.toLowerCase()) > -1 ||
-                    emoji.description_ja_jp.toLowerCase().indexOf(key.toLowerCase()) > -1) {
+                if (unicode2Emoji(emoji.unicode || '') === key ||
+                    (emoji.keywords || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                    (emoji.description || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                    (emoji.description_zh_cn || '').toLowerCase().indexOf(key.toLowerCase()) > -1 ||
+                    (emoji.description_ja_jp || '').toLowerCase().indexOf(key.toLowerCase()) > -1) {
                     if (category.id === "custom") {
                         customStore.push(emoji);
                     } else {
-                        keyHTML += `<button data-unicode="${emoji.unicode}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji)}">
-${unicode2Emoji(emoji.unicode, undefined, false, true)}</button>`;
+                        keyHTML += `<button data-unicode="${emoji.unicode || ''}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji)}">
+${unicode2Emoji(emoji.unicode || '', undefined, false, true)}</button>`;
                     }
                     maxCount++;
                 }
             } else {
-                if (window.siyuan.config.editor.emoji.includes(emoji.unicode)) {
+                if ((window.siyuan.config.editor.emoji || []).includes(emoji.unicode || '')) {
                     recentEmojis.push(emoji);
                 }
                 if (index < 2) {
-                    html += `<button data-unicode="${emoji.unicode}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji)}">
-${unicode2Emoji(emoji.unicode, undefined, false, true)}</button>`;
+                    html += `<button data-unicode="${emoji.unicode || ''}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji)}">
+${unicode2Emoji(emoji.unicode || '', undefined, false, true)}</button>`;
                 }
             }
         });
@@ -143,35 +162,141 @@ ${unicode2Emoji(emoji.unicode, undefined, false, true)}</button>`;
             html += "</div>";
         }
     });
+
+    // Process custom emojis
     if (key) {
         customStore.sort((a, b) => {
-            const aKeywords = a.keywords.split("/");
-            const bKeywords = b.keywords.split("/");
+            const aKeywords = (a.keywords || "").split("/");
+            const bKeywords = (b.keywords || "").split("/");
             if (aKeywords[aKeywords.length - 1].toLowerCase().indexOf(key.toLowerCase()) < bKeywords[bKeywords.length - 1].toLowerCase().indexOf(key.toLowerCase())) {
                 return -1;
             }
             return 0;
         }).sort((a, b) => {
-            const aKeywords = a.keywords.split("/");
-            const bKeywords = b.keywords.split("/");
+            const aKeywords = (a.keywords || "").split("/");
+            const bKeywords = (b.keywords || "").split("/");
             if (aKeywords[aKeywords.length - 1].toLowerCase().indexOf(key.toLowerCase()) === bKeywords[bKeywords.length - 1].toLowerCase().indexOf(key.toLowerCase()) && aKeywords[aKeywords.length - 1].length < bKeywords[bKeywords.length - 1].length) {
                 return -1;
             }
             return 0;
         }).forEach(item => {
             html += `<button data-unicode="${item.unicode}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(item)}">
-${unicode2Emoji(item.unicode, undefined, false, true)}</button>`;
+${unicode2Emoji(item.unicode || '', undefined, false, true)}</button>`;
         });
         html = html + keyHTML + "</div>";
     }
+
+    if (key && triggered_by !== "slash_hint") {
+        // Check for API key and search string before attempting external search
+        if (window.siyuan.config.appearance.remoteIconProvider !== "") {
+            if (window.siyuan.config.appearance.remoteIconProvider === "iconFinder") {
+                if (key && key.length > 2 && window.siyuan.config.appearance.iconFinderAPIKey && window.siyuan.config.appearance.iconFinderAPIKey.trim() !== "") {
+                    try {
+                        const externalIcons = await searchIconFinder(key, max || 50);
+
+                        if (externalIcons.length > 0) {
+                            externalIconsContent += `<div class="emojis__title fn__block">External Icons (${window.siyuan.config.appearance.remoteIconProvider})</div><div class="emojis__content">`;
+                            externalIconsContent += '<div class="fn__hr"></div>';
+
+                            externalIcons.forEach((icon) => {
+                                const urls = extractUrlsFromKeywords(icon.keywords || "");
+                                if (urls && urls.previewUrl) {
+                                    externalIconsContent += `<button 
+                  data-unicode="${icon.unicode || ''}"
+                  data-download-url="${urls.downloadUrl || ''}"
+                  class="emojis__item ariaLabel" 
+                  onmouseover="this.style.border='0.5px solid var(--b3-theme-on-background)'"
+                  onmouseout="this.style.border='none'"
+                  aria-label="${getEmojiDesc(icon)}">
+                  <img src="${urls.previewUrl}"/>
+                </button>`;
+                                }
+                            });
+
+                            externalIconsContent += "</div>";
+                        }
+                    } catch (error) {
+                        console.error("Error fetching external icons:", error);
+                    }
+                }
+            } else if (window.siyuan.config.appearance.remoteIconProvider === "flatIcon") {
+                if (key && key.length > 2 && window.siyuan.config.appearance.flatIconAPIKey && window.siyuan.config.appearance.flatIconAPIKey.trim() !== "") {
+                    try {
+                        const externalIcons = await searchFlatIcon(key, max || 50);
+
+                        if (externalIcons.length > 0) {
+                            externalIconsContent += `<div class="emojis__title fn__block">External Icons (${window.siyuan.config.appearance.remoteIconProvider})</div><div class="emojis__content">`;
+                            externalIconsContent += '<div class="fn__hr"></div>';
+
+                            externalIcons.forEach((icon) => {
+                                const urls = extractUrlsFromKeywords(icon.keywords || "");
+                                if (urls) {
+                                    externalIconsContent += `<button 
+                  data-unicode="${icon.unicode || ''}"
+                  data-download-url="${urls.downloadUrl || ''}"
+                  class="emojis__item ariaLabel" 
+                  onmouseover="this.style.border='0.5px solid var(--b3-theme-on-background)'"
+                  onmouseout="this.style.border='none'"
+                  aria-label="${getEmojiDesc(icon)}">
+                  <img src="${urls.previewUrl}"/>
+                </button>`;
+                                }
+                            });
+
+                            externalIconsContent += "</div>";
+                        }
+                    } catch (error) {
+                        console.error("Error fetching external icons:", error);
+                    }
+                }
+            } else if (window.siyuan.config.appearance.remoteIconProvider === "icon8") {
+                // if (
+                //   key &&
+                //   key.length > 2 &&
+                //   window.siyuan.config.appearance.icon8APIKey &&
+                //   window.siyuan.config.appearance.icon8APIKey.trim() !== ""
+                // ) {
+                // }
+                try {
+                    const externalIcons = await searchIcon8(key, max || 50);
+
+                    if (externalIcons.length > 0) {
+                        externalIconsContent += `<div class="emojis__title fn__block">External Icons (${window.siyuan.config.appearance.remoteIconProvider})</div><div class="emojis__content">`;
+                        externalIconsContent += '<div class="fn__hr"></div>';
+
+                        externalIcons.forEach((icon) => {
+                            const urls = extractUrlsFromKeywords(icon.keywords || "");
+                            if (urls) {
+                                externalIconsContent += `<button 
+                data-unicode="${icon.unicode || ''}"
+                data-download-url="${urls.downloadUrl || ''}"
+                class="emojis__item ariaLabel" 
+                onmouseover="this.style.border='0.5px solid var(--b3-theme-on-background)'"
+                onmouseout="this.style.border='none'"
+                aria-label="${getEmojiDesc(icon)}">
+                <img src="${urls.previewUrl}"/>
+              </button>`;
+                            }
+                        });
+
+                        externalIconsContent += "</div>";
+                    }
+                } catch (error) {
+                    console.error("Error fetching external icons:", error);
+                }
+            }
+        }
+        html += externalIconsContent;
+    }
+
     let recentHTML = "";
     if (recentEmojis.length > 0) {
         recentHTML = `<div class="emojis__title" data-type="0">${window.siyuan.languages.recentEmoji}</div><div class="emojis__content">`;
-        window.siyuan.config.editor.emoji.forEach(emojiUnicode => {
+        (window.siyuan.config.editor.emoji || []).forEach(emojiUnicode => {
             const emoji = recentEmojis.filter((item) => item.unicode === emojiUnicode);
             if (emoji[0]) {
-                recentHTML += `<button data-unicode="${emoji[0].unicode}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji[0])}">
-${unicode2Emoji(emoji[0].unicode, undefined, false, true)}
+                recentHTML += `<button data-unicode="${emoji[0].unicode || ''}" class="emojis__item ariaLabel" aria-label="${getEmojiDesc(emoji[0])}">
+${unicode2Emoji(emoji[0].unicode || '', undefined, false, true)}
 </button>`;
             }
         });
@@ -229,7 +354,7 @@ const renderEmojiContent = (previousIndex: string, previousContentElement: Eleme
     previousContentElement.removeAttribute("style");
 };
 
-export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", position: IPosition, callback?: (emoji: string) => void, dynamicImgElement?: HTMLElement) => {
+export const openEmojiPanel = async (id: string, type: "doc" | "notebook" | "av", position: IPosition, callback?: (emoji: string) => void, dynamicImgElement?: HTMLElement) => {
     if (type !== "av") {
         window.siyuan.menus.menu.remove();
     } else {
@@ -258,6 +383,7 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
         dynamicCurrentObj.content = dynamicCurrentUrl.get("content") || "SiYuan";
     }
 
+    const initialEmojis = await filterEmoji();
     const dialog = new Dialog({
         disableAnimation: true,
         transparent: true,
@@ -285,7 +411,7 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
                 <span class="block__icon block__icon--show fn__flex-center ariaLabel" data-action="random" aria-label="${window.siyuan.languages.random}"><svg><use xlink:href="#iconRefresh"></use></svg></span>
                 <span class="fn__space"></span>
             </div>
-            <div class="emojis__panel">${filterEmoji()}</div>
+            <div class="emojis__panel">${initialEmojis}</div>
             <div class="fn__flex">
                 ${[
             ["2b50", window.siyuan.languages.recentEmoji],
@@ -382,25 +508,33 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
     dialog.element.querySelector(".emojis__item").classList.add("emojis__item--current");
     const emojiSearchInputElement = dialog.element.querySelector('[data-type="tab-emoji"] .b3-text-field') as HTMLInputElement;
     const emojisContentElement = dialog.element.querySelector(".emojis__panel");
-    emojiSearchInputElement.addEventListener("compositionend", () => {
-        emojisContentElement.innerHTML = filterEmoji(emojiSearchInputElement.value);
-        if (emojiSearchInputElement.value) {
+
+    // Modify the input event handler in openEmojiPanel to use debounce
+    const handleEmojiSearch = debounce(async (value: string) => {
+        emojisContentElement.innerHTML = await filterEmoji(value);
+        if (value) {
             emojisContentElement.nextElementSibling.classList.add("fn__none");
         } else {
             emojisContentElement.nextElementSibling.classList.remove("fn__none");
         }
         emojisContentElement.scrollTop = 0;
         dialog.element.querySelector(".emojis__item")?.classList.add("emojis__item--current");
-        if (emojiSearchInputElement.value === "") {
+        if (value === "") {
             lazyLoadEmoji(dialog.element);
         }
         lazyLoadEmojiImg(dialog.element);
-    });
-    emojiSearchInputElement.addEventListener("input", (event: InputEvent) => {
+    }, 1000); // 1000ms debounce delay
+
+    // Update the input event listener
+    emojiSearchInputElement.addEventListener("input", async (event: InputEvent) => {
         if (event.isComposing) {
             return;
         }
-        emojisContentElement.innerHTML = filterEmoji(emojiSearchInputElement.value);
+        handleEmojiSearch(emojiSearchInputElement.value);
+    });
+
+    emojiSearchInputElement.addEventListener("compositionend", async () => {
+        emojisContentElement.innerHTML = await filterEmoji(emojiSearchInputElement.value);
         if (emojiSearchInputElement.value) {
             emojisContentElement.nextElementSibling.classList.add("fn__none");
         } else {
@@ -413,7 +547,7 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
         }
         lazyLoadEmojiImg(dialog.element);
     });
-    emojiSearchInputElement.addEventListener("keydown", (event: KeyboardEvent) => {
+    emojiSearchInputElement.addEventListener("keydown", async (event: KeyboardEvent) => {
         if (event.isComposing) {
             return;
         }
@@ -425,7 +559,23 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
             return;
         }
         if (event.key === "Enter") {
-            const unicode = currentElement.getAttribute("data-unicode");
+            let unicode = currentElement.getAttribute("data-unicode");
+
+            // Handle external/remote icons
+            if (unicode.startsWith("external-")) {
+                const downloadUrl = currentElement.getAttribute("data-download-url");
+                try {
+                    const iconId = unicode.replace("external-", "");
+                    const assetPath = await downloadAndStoreIcon(downloadUrl, iconId);
+                    if (assetPath) {
+                        unicode = assetPath.replace("emojis/", "").replace(/^\//, "");
+                    }
+                    // unicode = assetPath; // emojis/external/external-653276-20250508012313-7g2kc0m.png
+                } catch (error) {
+                    console.error("Failed to process external icon:", error);
+                }
+            }
+
             if (type === "notebook") {
                 fetchPost("/api/notebook/setNotebookIcon", {
                     notebook: id,
@@ -531,7 +681,7 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
     lazyLoadEmoji(dialog.element);
     lazyLoadEmojiImg(dialog.element);
     // 不能使用 getEventName 否则 https://github.com/siyuan-note/siyuan/issues/5472
-    dialog.element.addEventListener("click", (event) => {
+    dialog.element.addEventListener("click", async (event) => {
         let target = event.target as HTMLElement;
         while (target && target !== dialog.element) {
             if (target.classList.contains("emojis__type")) {
@@ -575,6 +725,21 @@ export const openEmojiPanel = (id: string, type: "doc" | "notebook" | "av", posi
                 let unicode = "";
                 if (target.classList.contains("emojis__item")) {
                     unicode = target.getAttribute("data-unicode");
+                    // Handle external/remote icons
+                    if (unicode !== null && unicode.startsWith("external-")) {
+                        const downloadUrl = target.getAttribute("data-download-url");
+                        try {
+                            const iconId = unicode.replace("external-", "");
+                            const assetPath = await downloadAndStoreIcon(downloadUrl, iconId);
+                            if (assetPath) {
+                                unicode = assetPath.replace("emojis/", "").replace(/^\//, "");
+                            }
+                            // unicode = assetPath; // emojis/external/external-653276-20250508012313-7g2kc0m.png
+                        } catch (error) {
+                            console.error("Failed to process external icon:", error);
+                            break;
+                        }
+                    }
                     dialog.destroy();
                 } else if (target.classList.contains("emoji__dynamic-item")) {
                     unicode = target.getAttribute("src");
@@ -757,3 +922,320 @@ export const reloadEmoji = () => {
         });
     });
 };
+
+export const searchIconFinder = async (query: string, maxResults: number = 20): Promise<IEmojiItem[]> => {
+    try {
+        const ICONFINDER_API_KEY = window.siyuan.config.appearance.iconFinderAPIKey;
+        if (!ICONFINDER_API_KEY || ICONFINDER_API_KEY.trim() === "") { // Added explicit check
+            console.warn("IconFinder API Key is not configured.");
+            return [];
+        }
+        const response = await fetch(`https://api.iconfinder.com/v4/icons/search?query=${encodeURIComponent(query)}&count=${maxResults}&premium=0`, {
+            headers: {
+                Authorization: `Bearer ${ICONFINDER_API_KEY}`,
+            },
+        });
+
+        if (!response.ok) {
+            throw new Error(`IconFinder API error: ${response.statusText}`);
+        }
+
+        const data: IIconFinderResponse = await response.json();
+        // Defensive check: ensure data.icons exists and is an array
+        const nonPremiumIcons = (data.icons || []).filter((icon) => !icon?.is_premium); // Added check for icon existence and is_premium
+
+        const transformedIcons = nonPremiumIcons.map((icon): IEmojiItem => {
+            // Defensive check: Ensure icon.tags exists and is an array
+            const tags = Array.isArray(icon?.tags) ? icon.tags : []; // Added icon?.
+            const joinedTags = tags.join(", ");
+            const joinedKeywords = tags.join(" ");
+
+            const urls = getIconUrls(icon); // getIconUrls is now more robust
+            const downloadUrl = urls?.downloadUrl || ""; // Defensive read
+            const previewUrl = urls?.previewUrl || "";   // Defensive read
+            const urlData = `${downloadUrl}|${previewUrl}`;
+
+            return {
+                unicode: `external-${icon?.icon_id || Array(12).fill('').map(() => (Math.random() * 36).toString(36)[Math.floor(Math.random() * 36)]).join('')}`, // Fallback for icon_id
+                description: joinedTags,
+                description_zh_cn: joinedTags,
+                description_ja_jp: joinedTags,
+                keywords: `${joinedKeywords} __url__${urlData}`,
+            };
+        });
+
+        return transformedIcons;
+    } catch (error) {
+        console.error("IconFinder search failed:", error);
+        return [];
+    }
+};
+
+export const searchIcon8 = async (query: string, maxResults: number = 20): Promise<IEmojiItem[]> => {
+    try {
+        const response = await fetch(`https://search-app.icons8.com/api/iconsets/v7/search?amount=${maxResults}&offset=0&language=en&saveAnalytics=false&isOuch=true&replaceNameWithSynonyms=true&term=${encodeURIComponent(query)}`);
+
+        if (!response.ok) {
+            throw new Error(`Icon8 API error: ${response.statusText}`);
+        }
+
+        const data: IIcon8Response = await response.json();
+
+        // Filter non-premium icons (defensive access to data.icons)
+        const nonPremiumIcons = (data.icons || []).filter((icon) => { // Added data.icons || []
+            if (icon && "free" in icon && icon.free !== null) { // Added icon check
+                return icon.free === true;
+            } else {
+                return true; // Assume free if 'free' property is missing or unexpected
+            }
+        });
+
+        const icons = nonPremiumIcons.map((icon): IEmojiItem => {
+            const urls = getIconUrls(icon); // getIconUrls handles icon.name.toLowerCase() defensively
+            const downloadUrl = urls?.downloadUrl || ""; // Defensive read
+            const previewUrl = urls?.previewUrl || "";   // Defensive read
+            const urlData = `${downloadUrl}|${previewUrl}`;
+
+            // Defensive check for icon.name and icon.id
+            const iconName = icon?.name || "";
+            const iconId = icon?.id || Array(12).fill('').map(() => (Math.random() * 36).toString(36)[Math.floor(Math.random() * 36)]).join(''); // Fallback for icon.id
+
+            return {
+                unicode: `external-${iconId}`,
+                description: iconName,
+                description_zh_cn: iconName,
+                description_ja_jp: iconName,
+                keywords: `${iconName} __url__${urlData}`,
+            };
+        });
+        return icons;
+    } catch (error) {
+        console.error("Icon8 search failed:", error);
+        return [];
+    }
+};
+
+const searchFlatIcon = async (query: string, maxResults: number = 20): Promise<IEmojiItem[]> => {
+    try {
+        const FLAT_ICON_API_KEY = window.siyuan.config.appearance.flatIconAPIKey;
+        if (!FLAT_ICON_API_KEY || FLAT_ICON_API_KEY.trim() === "") { // Added explicit check
+            console.warn("FlatIcon API Key is not configured.");
+            return [];
+        }
+        // thumbnail_size
+        const response = await fetch(`https://api.freepik.com/v1/icons?term=${encodeURIComponent(query)}`, {
+            headers: {
+                "x-freepik-api-key": `${FLAT_ICON_API_KEY}`,
+            },
+        });
+
+        if (!response.ok) {
+            throw new Error(`FlatIcon API error: ${response.statusText}`);
+        }
+
+        const data: IFlatIconResponse = await response.json();
+
+        // Defensive check for data.data
+        return (data.data || []).map((icon): IEmojiItem => { // Added data.data || []
+            const urls = getIconUrls(icon);
+            const downloadUrl = urls?.downloadUrl || ""; // Defensive read
+            const previewUrl = urls?.previewUrl || "";   // Defensive read
+            const urlData = `${downloadUrl}|${previewUrl}`;
+
+            // Defensive check for icon.name and icon.id
+            const iconName = icon?.name || "";
+            const iconId = icon?.id || Array(12).fill('').map(() => (Math.random() * 36).toString(36)[Math.floor(Math.random() * 36)]).join(''); // Fallback for icon.id
+
+            return {
+                unicode: `external-${iconId}`,
+                description: iconName,
+                description_zh_cn: iconName,
+                description_ja_jp: iconName,
+                keywords: `${iconName} __url__${urlData}`,
+            };
+        }).slice(0, maxResults);
+    } catch (error) {
+        console.error("FlatIcon search failed:", error);
+        return [];
+    }
+};
+
+function extractUrlsFromKeywords(keywords: string): { downloadUrl: string; previewUrl: string } | null {
+    // Ensure keywords is a string before calling match
+    const urlMatch = (keywords || '').match(/__url__(.*?)\|(.*?)(?:\s|$)/); // Added (keywords || '')
+    if (urlMatch) {
+        return {
+            downloadUrl: urlMatch[1] || "", // Ensure returned strings are not undefined
+            previewUrl: urlMatch[2] || "",  // Ensure returned strings are not undefined
+        };
+    }
+    return null;
+}
+
+export const downloadAndStoreIcon = async (iconUrl: string, iconId: string): Promise<string> | null => {
+    try {
+        const assetPath = `/data/emojis/external/external-${iconId}.png`;
+
+        // Check if already exists first
+        try {
+            // Defensive check before fetchSyncPost for path
+            if (!assetPath) {
+                throw new Error("Asset path is undefined or empty.");
+            }
+            const getFileResponse = await fetchSyncPost("/api/file/getFile", {
+                path: assetPath,
+            });
+            if (getFileResponse.code === 200) {
+                return getFileResponse.data?.path || null; // Defensive read
+            }
+        } catch (e) {
+            // File doesn't exist or other error, continue with download
+            // console.warn("Local file check failed, proceeding with download:", e); // Optional: add warning
+        }
+
+        // Download the icon
+        let response: Response | null = null;
+        if (window.siyuan.config.appearance.remoteIconProvider === "iconFinder") {
+            const ICONFINDER_API_KEY = window.siyuan.config.appearance.iconFinderAPIKey;
+            if (!ICONFINDER_API_KEY) throw new Error("IconFinder API Key is missing."); // Redundant check, but adds robustness
+            response = await fetch(iconUrl, {
+                headers: {
+                    Authorization: `Bearer ${ICONFINDER_API_KEY}`,
+                },
+            });
+        } else if (window.siyuan.config.appearance.remoteIconProvider === "icon8") {
+            response = await fetch(iconUrl);
+        } else if (window.siyuan.config.appearance.remoteIconProvider === "flatIcon") {
+            const FLAT_ICON_API_KEY = window.siyuan.config.appearance.flatIconAPIKey;
+            if (!FLAT_ICON_API_KEY) throw new Error("FlatIcon API Key is missing."); // Redundant check, but adds robustness
+            const flatIconDownloadResponse = await fetch(iconUrl, {
+                headers: {
+                    "x-freepik-api-key": `${FLAT_ICON_API_KEY}`,
+                },
+            });
+
+            if (!flatIconDownloadResponse.ok) {
+                throw new Error(`FlatIcon download URL API error: ${flatIconDownloadResponse.status} ${flatIconDownloadResponse.statusText}`);
+            }
+
+            const flatIconDownloadData = await flatIconDownloadResponse.json();
+            // Assuming the structure is {"data":{"filename":"man","url":"..."}}
+            const actualDownloadUrl = flatIconDownloadData.data?.url;
+            if (!actualDownloadUrl) {
+                throw new Error("FlatIcon did not return a valid download URL.");
+            }
+            response = await fetch(actualDownloadUrl);
+        }
+
+        if (response === null) {
+            throw new Error("Failed to determine icon provider for download or response is null.");
+        }
+        if (!response.ok) {
+            throw new Error(`Failed to download icon: ${response.status} ${response.statusText}`);
+        }
+
+        const blob = await response.blob();
+        const formData = new FormData();
+
+        // Defensive checks for file name and type
+        const fileName = `external-${iconId}.png`;
+        const fileType = blob.type.startsWith("image/") ? blob.type : "image/png"; // Default to png if type is ambiguous
+
+        formData.append("file[]", new File([blob], fileName, { type: fileType }));
+        formData.append("assetsDirPath", "/emojis/external/");
+
+        const uploadAssetResponse = await fetchSyncPost(
+            "/api/asset/upload",
+            formData
+        );
+        if (uploadAssetResponse.code === 0) {
+            const succMap = uploadAssetResponse.data?.succMap; // Defensive read
+            const paths = succMap ? Object.values(succMap) : []; // Defensive read
+            if (paths && paths.length > 0) {
+                return paths[0] || null; // Ensure not undefined
+            } else {
+                return null;
+            }
+        } else {
+            console.error("Asset upload failed:", uploadAssetResponse.msg); // Log error message from backend
+            return null;
+        }
+    } catch (error) {
+        console.error("Failed to download and store icon:", error);
+        // Re-throw if it's a critical error or handle as per application's error policy
+        return null;
+    }
+};
+
+function getIconUrls(icon: IIconFinderResponseIcon | IIcon8ResponseIcon | IFlatIconDataItem, targetSize: number = 256): { downloadUrl: string; previewUrl: string } {
+    // --- ICONFINDER BRANCH ---
+    // Identify IconFinder icons by checking for the 'raster_sizes' property at the top level
+    if ('raster_sizes' in icon && Array.isArray(icon.raster_sizes)) {
+        const finderIcon = icon as IIconFinderResponseIcon;
+        // Defensive check for raster_sizes before sorting
+        const sizes = Array.isArray(finderIcon.raster_sizes) ? finderIcon.raster_sizes.sort((a, b) => {
+            const aSize = a?.size || 0; // Defensive read
+            const bSize = b?.size || 0; // Defensive read
+            return Math.abs(aSize - targetSize) - Math.abs(bSize - targetSize);
+        }) : [];
+
+        for (const size of sizes) {
+            // Defensive check for size and formats array
+            if (size && Array.isArray(size.formats)) {
+                const pngFormat = size.formats.find((f) => f?.format === "png"); // Defensive read
+                if (pngFormat) {
+                    return {
+                        downloadUrl: pngFormat.download_url || "", // Ensure string
+                        previewUrl: pngFormat.preview_url || "",   // Ensure string
+                    };
+                }
+            }
+        }
+        // Fallback for IconFinder if no PNGs or formats are found
+        if (sizes.length > 0 && sizes[0] && Array.isArray(sizes[0].formats) && sizes[0].formats.length > 0) {
+            const firstFormat = sizes[0].formats[0];
+            return {
+                downloadUrl: firstFormat.download_url || "", // Ensure string
+                previewUrl: firstFormat.preview_url || "",   // Ensure string
+            };
+        } else {
+            console.warn('IconFinder: No suitable raster sizes or formats found for icon:', finderIcon);
+            return { downloadUrl: "", previewUrl: "" };
+        }
+    }
+    // --- FLATICON BRANCH ---
+    // Identify FlatIcon icons by checking for the 'free_svg' property at the top level
+    else if ('free_svg' in icon) {
+        const flatIcon = icon as IFlatIconDataItem;
+        // Defensive check for thumbnails array
+        const thumbnails = Array.isArray(flatIcon.thumbnails) ? flatIcon.thumbnails.sort((a, b) => {
+            const aWidth = a?.width || 0; // Defensive read
+            const bWidth = b?.width || 0; // Defensive read
+            return Math.abs(aWidth - targetSize) - Math.abs(bWidth - targetSize);
+        }) : [];
+
+        const thumbnailUrl = thumbnails[0]?.url || ""; // Defensive read and fallback
+
+        return {
+            downloadUrl: `https://api.freepik.com/v1/icons/${flatIcon.id || ''}/download`, // Defensive check for id
+            previewUrl: thumbnailUrl,
+        };
+    }
+    // --- ICON8 BRANCH (DEFAULT/FALLBACK) ---
+    // If it's neither IconFinder nor FlatIcon, assume it's an Icon8 icon.
+    // This needs to be the final 'else' if Icon8 doesn't have a truly unique top-level property
+    // that distinguishes it from ALL other potential incoming types.
+    else {
+        const icon8Icon = icon as IIcon8ResponseIcon;
+        // Defensive check for name before toLowerCase
+        const icon8Name = (icon8Icon.name || "").toLowerCase(); // Defensive read
+
+        // Ensure icon.id exists
+        const icon8Id = icon8Icon.id || getRandom(); // Fallback for id if missing
+
+        return {
+            downloadUrl: `https://img.icons8.com/?id=${icon8Id}&format=png&size=${targetSize}&name=icons8-${icon8Name}-${targetSize}.png&fromSite=true`,
+            previewUrl: `https://img.icons8.com/?id=${icon8Id}&format=png&size=${targetSize}&name=icons8-${icon8Name}-${targetSize}.png&fromSite=true`,
+        };
+    }
+}
\ No newline at end of file
diff --git a/app/src/layout/dock/Files.ts b/app/src/layout/dock/Files.ts
index 07087e611..0f67be15d 100644
--- a/app/src/layout/dock/Files.ts
+++ b/app/src/layout/dock/Files.ts
@@ -127,6 +127,8 @@ export class Files extends Model {
         <svg><use xlink:href="#iconContract"></use></svg>
     </span>
     <div class="fn__space${window.siyuan.config.readonly ? " fn__none" : ""}"></div>
+    <span data-type="newNoteBook" class="block__icon b3-tooltips b3-tooltips__sw" aria-label="New NoteBook"><svg><use xlink:href='#iconFilesRoot'></use></svg></span>
+    <span class="fn__space"></span>
     <div data-type="more" class="b3-tooltips b3-tooltips__sw block__icon${window.siyuan.config.readonly ? " fn__none" : ""}" aria-label="${window.siyuan.languages.more}">
         <svg><use xlink:href="#iconMore"></use></svg>
     </div> 
@@ -203,6 +205,11 @@ export class Files extends Model {
             }
         });
         // 为了快捷键的 dispatch
+        this.actionsElement.querySelector('[data-type="newNoteBook"]').addEventListener("click", () => {
+            if (!window.siyuan.config.readonly) {
+                newNotebook();
+            }
+        });
         this.actionsElement.querySelector('[data-type="collapse"]').addEventListener("click", () => {
             Array.from(this.element.children).forEach(item => {
                 const liElement = item.firstElementChild;
@@ -1269,15 +1276,15 @@ aria-label="${ariaLabel}">${getDisplayName(item.name, true, true)}</span>
 
     private initMoreMenu() {
         window.siyuan.menus.menu.remove();
-        if (!window.siyuan.config.readonly) {
-            window.siyuan.menus.menu.append(new MenuItem({
-                icon: "iconFilesRoot",
-                label: window.siyuan.languages.newNotebook,
-                click: () => {
-                    newNotebook();
-                }
-            }).element);
-        }
+        // if (!window.siyuan.config.readonly) {
+        //     window.siyuan.menus.menu.append(new MenuItem({
+        //         icon: "iconFilesRoot",
+        //         label: window.siyuan.languages.newNotebook,
+        //         click: () => {
+        //             newNotebook();
+        //         }
+        //     }).element);
+        // }
         window.siyuan.menus.menu.append(new MenuItem({
             icon: "iconRefresh",
             label: window.siyuan.languages.rebuildIndex,
diff --git a/app/src/protyle/hint/index.ts b/app/src/protyle/hint/index.ts
index 336b9aa21..945bfc999 100644
--- a/app/src/protyle/hint/index.ts
+++ b/app/src/protyle/hint/index.ts
@@ -372,48 +372,55 @@ ${genHintItemHTML(item)}
             return;
         }
 
-        const panelElement = this.element.querySelector(".emojis__panel");
-        if (panelElement) {
-            panelElement.innerHTML = filterEmoji(value, 256);
-            if (value) {
-                panelElement.nextElementSibling.classList.add("fn__none");
+        const afterEmojiPanelInit = () => {
+            const firstEmojiElement = this.element.querySelector(".emojis__item");
+            if (firstEmojiElement) {
+                firstEmojiElement.classList.add("emojis__item--current");
+                this.element.classList.remove("fn__none");
+                const textareaPosition = getSelectionPosition(protyle.wysiwyg.element);
+                setPosition(this.element, textareaPosition.left, textareaPosition.top + 26, 30);
+                this.element.querySelector(".emojis__panel").scrollTop = 0;
             } else {
-                panelElement.nextElementSibling.classList.remove("fn__none");
+                this.element.classList.add("fn__none");
             }
-            lazyLoadEmojiImg(panelElement);
+        }
+
+        const panelElement = this.element.querySelector(".emojis__panel");
+        if (panelElement) {
+            filterEmoji(value, 256, "slash_hint").then(emojiHTML => {
+                panelElement.innerHTML = emojiHTML;
+                if (value) {
+                    panelElement.nextElementSibling.classList.add("fn__none");
+                } else {
+                    panelElement.nextElementSibling.classList.remove("fn__none");
+                }
+                lazyLoadEmojiImg(panelElement);
+            }).then(afterEmojiPanelInit);
         } else {
-            // max-height：min(402px,40vh) 和 .protyle-hint 保持一致，否则 emoji 不显示底部导航
-            this.element.innerHTML = `<div style="padding:0;max-height:min(402px,40vh);width:366px" class="emojis">
-<div class="emojis__panel">${filterEmoji(value, 256)}</div>
+            filterEmoji(value, 256, "slash_hint").then(emojiHTML => {
+                // max-height：min(402px,40vh) 和 .protyle-hint 保持一致，否则 emoji 不显示底部导航
+                this.element.innerHTML = `<div style="padding:0;max-height:min(402px,40vh);width:366px" class="emojis">
+<div class="emojis__panel">${emojiHTML}</div>
 <div class="fn__flex${value ? " fn__none" : ""}">
-    ${[
-                ["2b50", window.siyuan.languages.recentEmoji],
-                ["1f527", getEmojiTitle(0)],
-                ["1f60d", getEmojiTitle(1)],
-                ["1f433", getEmojiTitle(2)],
-                ["1f96a", getEmojiTitle(3)],
-                ["1f3a8", getEmojiTitle(4)],
-                ["1f3dd-fe0f", getEmojiTitle(5)],
-                ["1f52e", getEmojiTitle(6)],
-                ["267e-fe0f", getEmojiTitle(7)],
-                ["1f6a9", getEmojiTitle(8)],
-            ].map(([unicode, title], index) =>
-                `<button data-type="${index}" class="emojis__type ariaLabel" aria-label="${title}">${unicode2Emoji(unicode)}</button>`
-            ).join("")}
+        ${[
+                    ["2b50", window.siyuan.languages.recentEmoji],
+                    ["1f527", getEmojiTitle(0)],
+                    ["1f60d", getEmojiTitle(1)],
+                    ["1f433", getEmojiTitle(2)],
+                    ["1f96a", getEmojiTitle(3)],
+                    ["1f3a8", getEmojiTitle(4)],
+                    ["1f3dd-fe0f", getEmojiTitle(5)],
+                    ["1f52e", getEmojiTitle(6)],
+                    ["267e-fe0f", getEmojiTitle(7)],
+                    ["1f6a9", getEmojiTitle(8)],
+                ].map(([unicode, title], index) =>
+                    `<button data-type="${index}" class="emojis__type ariaLabel" aria-label="${title}">${unicode2Emoji(unicode)}</button>`
+                ).join("")}
 </div>
 </div>`;
-            lazyLoadEmoji(this.element);
-            lazyLoadEmojiImg(this.element);
-        }
-        const firstEmojiElement = this.element.querySelector(".emojis__item");
-        if (firstEmojiElement) {
-            firstEmojiElement.classList.add("emojis__item--current");
-            this.element.classList.remove("fn__none");
-            const textareaPosition = getSelectionPosition(protyle.wysiwyg.element);
-            setPosition(this.element, textareaPosition.left, textareaPosition.top + 26, 30);
-            this.element.querySelector(".emojis__panel").scrollTop = 0;
-        } else {
-            this.element.classList.add("fn__none");
+                lazyLoadEmoji(this.element);
+                lazyLoadEmojiImg(this.element);
+            }).then(afterEmojiPanelInit)
         }
     }
 
diff --git a/app/src/types/config.d.ts b/app/src/types/config.d.ts
index 51c80a2d7..d7b75fb00 100644
--- a/app/src/types/config.d.ts
+++ b/app/src/types/config.d.ts
@@ -230,6 +230,18 @@ declare namespace Config {
          * The language used by the current user
          */
         lang: TLang;
+        /**
+         * The remote icon provider
+         */
+        remoteIconProvider: string;
+        /**
+         * The api key for iconfinder.com
+         */
+        iconFinderAPIKey: string;
+        /**
+         * The api key for flaticon.com
+         */
+        flatIconAPIKey: string;
         /**
          * List of installed light themes
          */
diff --git a/app/src/types/index.d.ts b/app/src/types/index.d.ts
index 284e5e3c9..bd6016ec9 100644
--- a/app/src/types/index.d.ts
+++ b/app/src/types/index.d.ts
@@ -1038,3 +1038,115 @@ interface IAVCalc {
     operator?: string,
     result?: IAVCellValue
 }
+
+interface IIconFinderResponseIcon {
+  icon_id: number;
+  tags: string[];
+  published_at: string;
+  is_premium: boolean;
+  type: string;
+  containers: any[];
+  raster_sizes: Array<{
+    formats: Array<{
+      format: string;
+      preview_url: string;
+      download_url: string;
+    }>;
+    size: number;
+    size_width: number;
+    size_height: number;
+  }>;
+  vector_sizes: Array<{
+    formats: Array<{
+      format: string;
+      download_url: string;
+    }>;
+    target_sizes: number[][];
+    size: number;
+    size_width: number;
+    size_height: number;
+  }>;
+  styles: any[];
+  categories: any[];
+  is_icon_glyph: boolean;
+}
+
+interface IIconFinderResponse {
+  total_count: number;
+  icons: Array<IIconFinderResponseIcon>;
+}
+
+interface IIcon8ResponseIcon {
+  id: string;
+  name: string;
+  commonName: string;
+  category: string;
+  subcategory?: string;
+  platform: string;
+  free?: boolean;
+  isColor: boolean;
+  isExplicit: boolean;
+  authorApiCode: string;
+  sourceFormat: string;
+}
+
+interface IIcon8Response {
+  success: boolean;
+  parameters: {
+    amount: number;
+    countAll: number;
+    language: string;
+    foundLanguage: string;
+    offset: number;
+    term: string;
+    searchTranslations: {
+      [key: string]: string;
+    };
+  };
+  icons: Array<IIcon8ResponseIcon>;
+}
+
+interface IFlatIconDataItem {
+  id: number;
+  name: string;
+  created: string;
+  slug: string;
+  style: {
+    id: number;
+    name: string;
+  };
+  family: {
+    id: number;
+    name: string;
+    total: number;
+  };
+  free_svg: boolean;
+  author: {
+    id: number;
+    name: string;
+    slug: string;
+    avatar: string;
+    assets: number;
+  };
+  thumbnails: Array<{
+    width: number;
+    height: number;
+    url: string;
+  }>;
+  tags: Array<{
+    slug: string;
+    name: string;
+  }>;
+}
+
+interface IFlatIconResponse {
+  data: IFlatIconDataItem[];
+  meta: {
+    pagination: {
+      total: number;
+      last_page: number;
+      per_page: number;
+      current_page: number;
+    };
+  };
+}
\ No newline at end of file
diff --git a/kernel/conf/appearance.go b/kernel/conf/appearance.go
index ebd1002ac..c726c1f1e 100644
--- a/kernel/conf/appearance.go
+++ b/kernel/conf/appearance.go
@@ -33,6 +33,9 @@ type Appearance struct {
 	ThemeJS             bool               `json:"themeJS"`             // 是否启用了主题 JavaScript
 	CloseButtonBehavior int                `json:"closeButtonBehavior"` // 关闭按钮行为，0：退出，1：最小化到托盘
 	HideStatusBar       bool               `json:"hideStatusBar"`       // 是否隐藏底部状态栏
+	RemoteIconProvider       string               `json:"remoteIconProvider"`       // remote icon provider, e.g. icon8
+	IconFinderAPIKey       string               `json:"iconFinderAPIKey"`       // api key for iconfinder.com
+	FlatIconAPIKey       string               `json:"flatIconAPIKey"`       // api key for flaticon.com
 }
 
 func NewAppearance() *Appearance {
@@ -45,6 +48,9 @@ func NewAppearance() *Appearance {
 		CodeBlockThemeLight: "github",
 		CodeBlockThemeDark:  "base16/dracula",
 		Lang:                "en_US",
+		RemoteIconProvider:	 "",
+		IconFinderAPIKey:	 "",
+		FlatIconAPIKey:	 	 "",
 		CloseButtonBehavior: 0,
 		HideStatusBar:       false,
 	}
